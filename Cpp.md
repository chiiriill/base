# C++

## Инициализация статических переменных внутри класса 

Начиная с C++17 можно объявлять и определять статические константы в классе без проблем с ODR-use и прочими приколами, а самое главное можно через inline

```c++
class C {
  public:
    static inline constexpr std::size_t kMax{5U};
    static inline const std::string kName{"class C"};
};
```

## Перегрузка унарных операций

Префиксный:

```c++
Monstr& operator++() {
    ++health;
    return *this;
}
```

Постфиксный:

```c++
Monstr operator++(int) {
    Monstr M(*this);
    health++;
    return M;
}
```

## Перегрузка бинарных операций

Бинарная функция-операция, определяемая внутри класса, должна быть представлена с помощью нестатического метода с параметрами, при этом вызвавший ее объект считается первым операндом:

```c++
class Monstr {
  ...
  bool operator >(const Monstr &M) {
    if( health > M.health ) return true;
    return false;
  }
};
```

Если функция определяется вне класса, она должна иметь два параметра типа класса:

```c++
bool operator >(const Monstr &M1. const Monstr &M2){
  if( Ml.get_health() > M2.getHealth()) return true:
  return false;
} 
```

## Перегрузка операции приведения типа

Можно определить функции-операции, которые будут осуществлять преобразование объекта класса к другому хипу. Формат:

```c++
operator имя_нового_типа (); 
```

Тип возвращаемого значения и параметры указывать не требуется. Можно определять виртуальные функции преобразования типа.

```c++
Monstr::operator int(){return health;}
...
Monstr Vasia; cout << int(Vasia):
```

## Перегрузка операции вызова функции

Класс, в котором определена операция вызова функции, называется функциональным. От такого класса не требуется наличия других полей и методов:

```c++
class IfGreater{
public:
  int operator () (int a, int b) const {
    return a > b;
  }
};
```